## CSE 331 hw-poly Questions
## Part 0
###########################################################################

1. Multiplication Pseudocode
r = p * q:
    set r = q by making a term-by-term copy of all terms in q to r
        {Inv: r = q * p0 * p1 * ... * p_i, where p_i is the ith term in p}
    foreach term, t_p, in p:
        set d_p = the degree of t_p
        if any term, t_r, in r has the same degree as d_p,
            then replace t_r in r with the product of t_p and t_r
            else insert t_p using production into r as a new term (r = t_p * r)


2. Division Pseudocode
q = u / v:
    set q = 0
    set d_v = the highest degree in v
    set r = u by making a term-by-term copy of all terms in u to r
    {Inv: u = v * q + r}
    while r is not 0:
        set d_r = the highest degree in u
        if d_r is greater or equal to d_v
           then set t as the division　of the leading term of r and leading term of v
                replace q with the sum of q and t
                replace r with the subtraction of r by the product of t and v
           else return q


3. Division Example:
// u = q * v + r
// (x3+x-1) / (x+1) = x2-x+2
u = x^3+x-1
v = x+1
q = 0
d_v = 1
r = copy of u = x^3+x-1
while r is not 0:
    Iteration 1: d_v = 1, u = x^3+x-1, v = x+1, q = 0, r = x^3+x-1
        [set d_r = the highest degree in r] d_r = 3
        [if d_r is greater or equal to d_v] YES. 3 >= 1
            [then t = leading term of r / leading term of v, q = q+t, r = r-(t*v)] t = x^2, q = x^2, r = -x^2+x-1
            [else return q]

    Iteration 2: d_v = 1, u = x^3+x-1, v = x+1, q = x^2, r = -x^2+x-1
        [set d_r = the highest degree in u] d_r = 2
        [if d_r is greater or equal to d_v] YES. 2 >= 1
            [then t = leading term of r / leading term of v, q = q+t, r = r-(t*v)] t = -x, q = x^2-x, r = 2x-1
            [else return q]

    Iteration 3: d_v = 1, u = x^3+x-1, v = x+1, q = x^2-x, r = 2x-1
        [set d_r = the highest degree in u] d_r = 2
        [if d_r is greater or equal to d_v] YES. 1 >= 1
            [then t = leading term of r / leading term of v, q = q+t, r = r-(t*v)] t = 2, q = x^2-x+2, r = -3
            [else return q]

    Iteration 4: d_v = 1, u = x^3+x-1, v = x+1, q = x^2-x+2, r = -3
        [set d_r = the highest degree in u] d_r = 0
        [if d_r is greater or equal to d_v] No. 0 < 1
            [then t = leading term of r / leading term of v, q = q+t, r = r-(t*v)]
            [else return q] return q = x^2-x+2
[Done] q = x^2-x+2



## Part 1
###########################################################################

1. Weakened Rep Invariant
The toString() method uses the gcd() method and have to output the rational
number in reduced form. This method would become less efficient because it
have to implements to have outputs in reduced terms. The constructor with
parameters of numerator and denominator will be simplified and more
efficient. It doesn't need to make sure that a new RatNum is in reduced form.


2. Alternate add, sub, mul, div
In the spec， the RatNum class should represent an immutable rational
number. However, the implementation in the question for these methods
would mutate the fields in the current instance of the whole object.
Although a @spec.requires is mentioned in the method specifications, it
still lack a @spec.effects clause. Therefore, these methods is supposed not
to change the values of the existing object, but is doing so.


3. Constructor checkReps
It is because RatNum is an immutable class, all the fields should never be
modified after constructed. Also, all the mutators will always return a new
instance of RatNum.
In addition, constructors will always violate checkRep() at the very
beginning, due to no instance has been made and the values of the numerator
and denominator are null.



## Part 2
###########################################################################

1. Calls to checkRep in RatTerm
Because the entire RatTerm is immutable, and all the implemented methods are
producers, which return new RatTerm instead of modifying the instances. So
the checkRep() method is only called at he end of the constructor.


2. Weakened Rep Invariant
The toString() method will be changed to find a case of a coefficient of
zero with an exponent of non-zero. It need to append a 0 to the string if
the coefficient is zero. This method would become less efficient due to
adding more conditional statements for RatTerm of zero cases.


3. Alternate Rep Invariant
The constructor will need to check if a coefficient of NaN is passed. If so,
it need to construct the exponent to 0, instead of making it to the parameter
one. This method would become less efficient due to adding more conditional
statements for RatTerm of NaN cases.


4. Preferred Invariants
I would prefer to use the invariants of (coeff.equals(RatNum.ZERO) ⇒ expt = 0;)
Because it only affect the efficiency for the toString() method. There's no
need to consider a NaN as coefficient for methods of those calculation; for
instance, NaN*x^74.



## Part 3
###########################################################################

1. Calls to checkRep in Rat_poly
Because the RatPoly is immutable, there are only constructors and producer methods.
So the checkRep() method is only called at he end of the constructor.
checkRep() method is also called when a method needs to return a RatPoly object to
ensure the rep invariants are maintained before being returned in methods of
mul(), div(), and integrate()


2. Alternate Representation
The advantage is that doing calculations using the coefficients and exponents of
the RatPoly would be simplified, because we will be more easier to access them.
